---
title: 前端面试题 - React篇
categories: [前端,面试题,React]
tags: [前端,面试题,React ]
date: 2024-09-08
---

前端面试题 - React篇

<!--more-->

## 六、React篇

### react有哪些hooks

**useState**：用于在函数组件中声明状态变量。

**useEffect**：用于在函数组件中执行副作用操作，如数据获取、订阅等。

**useContext**：用于在组件中访问上下文对象（context）。

**useReducer**：用于在复杂状态管理中代替 useState，类似于 Redux 的 reducer。

**useCallback**：返回一个 memoized 的回调函数，用于避免不必要的函数重新创建。

**useMemo**：返回一个 memoized 值，用于避免不必要的计算。

**useRef**：返回一个可变的 ref 对象，用于访问 DOM 元素或保持可变值。

**useImperativeHandle**：与 `forwardRef` 一起使用，自定义暴露给父组件的 ref 属性。

**useLayoutEffect**：与 useEffect 类似，但它在所有 DOM 变更之后同步调用

**useDebugValue**：用于在 React 开发者工具中显示自定义 hook 的标签。

### ueseffect跟uselouyeffect有什么区别

1. **执行时机**：
   - `useEffect`：在浏览器完成渲染之后异步执行。
   - `useLayoutEffect`：在 DOM 更新后同步执行，在浏览器绘制之前。
2. **使用场景**：
   - `useEffect`：适用于大多数副作用操作，如数据获取、订阅等，不会阻塞渲染。
   - `useLayoutEffect`：适用于需要同步读取布局或强制同步 DOM 变更的操作。
3. **性能影响**：
   - `useEffect`：不会阻塞浏览器的渲染，因此对性能影响较小。
   - `useLayoutEffect`：会阻塞浏览器的渲染，可能会影响性能，应该谨慎使用。



### useMome是做什么用的

`useMemo` 用于优化性能，通过记忆化计算结果，避免在每次渲染时都进行昂贵的计算。它的使用场景主要包括计算昂贵的值和防止创建新的对象或数组。



### 说一下reducer 提交一次异步修改的过程

使用 Redux 来提交一次异步修改通常涉及以下几个步骤：定义 action、创建 reducer、配置 store、使用中间件（如 Redux Thunk 或 Redux Saga）来处理异步逻辑，最后在组件中调度这些 action。



### 说一下react fiber原理

React Fiber 旨在提高 React 应用的性能和响应性。Fiber 的核心理念是将可中断、可恢复的更新引入到 React 渲染过程中，从而更好地处理复杂的用户界面。

**Fiber 的工作原理**

React Fiber 通过以下几个核心概念和机制来实现其目标：

1. **Fiber 节点**：每个组件对应一个 Fiber 节点，Fiber 节点包含了组件的状态、props、DOM 引用等信息。Fiber 节点的链表结构使得 React 可以更灵活地管理和调度更新任务。
2. **双缓冲机制**：React Fiber 使用双缓冲机制，其中一个树代表当前屏幕上显示的 UI（current tree），另一个树用于存储正在计算的新 UI（work-in-progress tree）。在更新过程中，React 在 work-in-progress tree 上执行任务，并在任务完成后将其切换为当前树。
3. **工作单元（Work Units）**：React 将更新任务拆分成多个小的工作单元，每个工作单元对应一个 Fiber 节点。React 可以在执行一部分工作单元后暂停，处理其他高优先级任务，然后继续未完成的工作单元。
4. **优先级调度**：React Fiber 引入了优先级调度机制，不同的更新任务根据其优先级被分配不同的时间片。高优先级任务（如用户输入）会优先处理，低优先级任务（如数据加载）会延后处理。

React Fiber 通过引入可中断和可恢复的更新机制，使得 React 能够更好地处理复杂的用户界面，提高了应用的响应性。Fiber 的细粒度更新、双缓冲机制和优先级调度等特性，使得 React 在处理大型和复杂应用时表现更加出色。



### 1、讲讲什么是 JSX ？

当 Facebook 第一次发布 React 时，他们还引入了一种新的 JS 方言 JSX，将原始 HTML 模板嵌入到 JS 代码中。JSX 代码本身不能被浏览器读取，必须使用Babel和webpack等工具将其转换为传统的JS。很多开发人员就能无意识使用 JSX，因为它已经与 React 结合在一直了。

```jsx
 class MyComponent extends React.Component {  render() {    let props = this.props;      return (      <div className="my-component">      <a href={props.url}>{props.name}</a>      </div>    );  }}	
```

JSX的特点
	可以将HTML语言直接写在JavaScript语言之中，不加任何引号，这就是JSX的语法，它允许HTML与JavaScript的混写。
	JSX允许直接在模板插入JavaScript变量。如果这个变量是一个数组，则会展开这个数组的所有成员。
防注入攻击
	在JSX中嵌入用户输入是安全的；
	React DOM在渲染之前默认会过滤所有传入的值。它可以确保应用不会被注入攻击。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止XSS(跨站脚本攻击)
	Babel转译器会把JSX转换成一个名为React.createElement()的方法调用。
	如果在普通的html里面要写jsx语法，要将script的type改成text/jsx，这是因为React独有的JSX语法跟JavaScript不兼容。凡是使用JSX的地方，都要加上type=“text/jsx”。其次，React提供俩个库:react.js和JSXTransformer.js，它们必须首先加载。其中，JSXTransformer.js的作用是将JSX语法转为JavaScript语法。这一步很消耗时间，实际上线的时候，应该把它放到服务器完成。



### 2、React 的生命周期方法有哪些？

React的生命周期方法有很多，并且在不同的React版本中可能会有一些变化。为了更好地理解React的生命周期，我将它们按照React 16版本及其之后的版本进行整理，以帮助你更好地理解。

在React 16版本及其之后，React的生命周期方法可分为三个阶段：挂载阶段、更新阶段和卸载阶段。以下是React 16版本及其之后的生命周期方法列表：

**挂载阶段**：

> constructor：组件实例化时调用，用于初始化状态和绑定方法。
> static getDerivedStateFromProps：在渲染之前调用，用于根据新的属性值计算并返回一个新的状态。
> render：渲染组件的内容。
> componentDidMount：组件挂载后调用，可以进行异步操作、订阅事件等。

**更新阶段**：

> static getDerivedStateFromProps：在渲染之前调用，用于根据新的属性值计算并返回一个新的状态。
> shouldComponentUpdate：在渲染之前调用，用于决定是否重新渲染组件，默认返回true。
> render：渲染组件的内容。
> getSnapshotBeforeUpdate：在最终将内容渲染到DOM之前调用，用于获取DOM更新前的快照。
> componentDidUpdate：组件更新后调用，可以进行DOM操作、发起网络请求等。

**卸载阶段**：

> componentWillUnmount：组件卸载前调用，可以进行清理操作，如取消订阅、清除定时器等。

另外，React 16.3版本后引入了以下生命周期方法：

> - static getDerivedStateFromError：在子组件渲染过程中，如果发生错误，会调用该方法，返回一个新的状态。
> - componentDidCatch：在子组件渲染过程中，如果发生错误，会调用该方法，用于记录错误信息或上报错误。



需要注意的是，React 17版本之后，一些生命周期方法被标记为过时，并推荐使用其他替代方法来实现相应的功能。在使用React时，可以根据具体的需求和React版本来选择合适的生命周期方法。同时，React还提供了钩子函数的方式（如useEffect钩子）来完成与生命周期相关的操作，这也是React 16.8版本及其之后的新特性。 





### 3、React的Hooks详解

Hook是什么
Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。Hook 不能在 class 组件中使用 —— 这使得你不使用 class 也能使用 React。
React 内置了一些像 useState 这样的 Hook。你也可以创建你自己的 Hook 来复用不同组件之间的状态逻辑。

React提供了多个常用的Hooks，用于在函数组件中管理状态、处理副作用和访问React的上下文等。以下是React所有的常用Hooks列表：

useState：用于在函数组件中添加状态。
useEffect：用于在函数组件中执行副作用操作。
useContext：用于在函数组件中访问React的上下文。
useReducer：用于在函数组件中使用Reducer模式来管理状态。
useRef：用于在函数组件中创建可变的引用。
useMemo：用于在函数组件中缓存计算的值。
useCallback：用于在函数组件中缓存函数。
useLayoutEffect：类似于useEffect，但在DOM更新之后同步执行。
useImperativeHandle：用于在函数组件中自定义外部组件实例的暴露。
useDebugValue：用于在自定义Hooks中显示自定义的调试值。
这些Hooks可以帮助你更方便地编写和管理React函数组件。同时，你还可以根据需要自定义自己的Hooks来封装和复用逻辑。React的Hooks特性在React 16.8版本及其之后引入，它们提供了一种更简洁、灵活的方式来编写可复用的React组件逻辑。



### 4、React和Vue.js的相似性和差异性是什么？

相似性如下。

（1）都是用于创建UI的 JavaScript库。

（2）都是快速和轻量级的代码库（这里指 React核心库）。

（3）都有基于组件的架构。

（4）都使用虚拟DOM。

（5）都可以放在单独的HTML文件中，或者放在 Webpack设置的一个更复杂的模块中。

（6）都有独立但常用的路由器和状态管理库。

它们最大的区别在于 Vue. js通常使用HTML模板文件，而 React完全使用 JavaScript创建虚拟DOM。 Vue. js还具有对于“可变状态”的“ reactivity”的重新渲染的自动化检测系统。（React一般适用于大型项目）





### 5、React的功能是什么？ 

React的主要功能如下：

1. 它使用**虚拟DOM**而不是真实DOM。
2. 它使用**服务器端渲染**。
3. 它遵循**单向数据流**或数据绑定。



### 6、React的一些主要优点是？

1. 它提高了应用程序的性能
2. 它可以方便地在客户端和服务器端使用
3. 由于有了JSX，代码的可读性提高了
4. React易于与其他框架（如Meteor，Angular等）集成
5. 使用React，编写UI测试用例变得非常容易



### 7、React的局限性是什么？

1. React只是一个库，而不是一个成熟的框架
2. 它的图书馆很大，需要花费一些时间来理解
3. 对于新手程序员而言，理解起来可能有点困难
4. 由于使用内联模板和JSX，编码变得复杂



### 8、如何理解React State不可变性的原则

在 React 中，不可变性是指数据一旦被创建，就不能被修改。React 推崇使用不可变数据的原则，这意味着在更新数据时，应该创建新的数据对象而不是直接修改现有的数据。

**以下是理解 React 中不可变性原则的几个关键点：**

1. 数据一旦创建就不能被修改：在 React 中，组件的状态（state）和属性（props）应该被视为不可变的。一旦创建了状态或属性对象，就不应该直接修改它们的值。这样可以确保组件的数据在更新时是不可变的，从而避免意外的数据改变和副作用。
2. 创建新的数据对象：当需要更新状态或属性时，应该创建新的数据对象。这可以通过使用对象展开运算符、数组的 concat()、slice() 等方法，或者使用不可变数据库（如Immutable.js、Immer 等）来创建新的数据副本。
3. 比较数据变化：React 使用 Virtual DOM 来比较前后两个状态树的差异，并仅更新需要更新的部分。通过使用不可变数据，React 可以更高效地进行比较，因为它可以简单地比较对象引用是否相等，而不必逐个比较对象的属性。
4. 性能优化：使用不可变数据可以带来性能上的优势。由于 React 可以更轻松地比较前后状态的差异，可以减少不必要的重新渲染和组件更新，提高应用的性能和响应性。

**不可变性的原则在 React 中有以下好处：**

简化数据变更追踪：由于数据不可变，可以更轻松地追踪数据的变化。这样可以更好地理解代码的行为和数据的流动。
避免副作用：可变数据容易引发副作用和难以追踪的 bug。通过使用不可变数据，可以避免许多与副作用相关的问题。
方便的历史记录和回滚：不可变数据使得记录和回滚应用状态的历史变得更容易。可以在不改变原始数据的情况下，创建和保存不同时间点的数据快照



### 9、React的特点和关键版本区别？

react的关键版本
React16之前对virtural dom的更新和渲染是同步的。就是当一次更新或者一次加载开始以后，diff virtual dom并且渲染的过程是一口气完成的。如果组件层级比较深，相应的堆栈也会很深，长时间占用浏览器主线程，一些类似用户输入、鼠标滚动等操作得不到响应。

React16开始用了分片的方式解决上面的问题
就是把一个任务分成很多小片，当分配给这个小片的时间用尽的时候，就检查任务列表中有没有新的、优先级更高的任务，有就做这个新任务，没有就继续做原来的任务。这种方式被叫做异步渲染(Async Rendering)。

React的特点

1. React速度很快
   与其他框架相比，React采取了一种独特操作DOM的方式。
   它并不直接对DOM进行操作。它引入了一个叫虚拟DOM的概念，安插在JavaScript逻辑和实际的DOM之间。这一概念提高了Web性能。在UI渲染过程中，React通过在虚拟DOM中的微操作来实现对实际DOM的局部更新。
   将视图与数据进行单向绑定，绝大部分操作都可以不再直接操作DOM，而是通过改变数据来更新视图，这对于前端是具有里碑意义的。
2. 跨浏览器兼容
   虚拟DOM帮助我们解决了跨浏览器问题，它为我们提供了标准化的API，甚至在IE8中都是没问题的。
3. 模块化
   为程序编写独立的模块化UI组件，并且它们可以引入其他组件。这等同于提高了代码的可维护性。
4. 单向数据流，让事情一目了然
   Flux是一个用于在JavaScript应用中创建单向数据层的架构，它随着React视图库的开发而被Facebook概念化。它只是一个概念，而非特定工具的实现。它可以被其它框架吸纳。例如，Alex Rattray有一个很好的Flux实例，在React中使用了Backbone的集合和模型。
5. 纯粹的JavaScript
   现代Web应用程序与传统的Web应用有着不同的工作方式。
   例如，视图层的更新需要通过用户交互而不需要请求服务器。因此视图和控制器非常依赖彼此。
   许多框架使用Handlebars或Mustache等模板引擎来处理视图层。但React相信视图和控制器应该相互依存在一起而不是使用第三方模板引擎，而且最重要的是，它是纯粹的JavaScript程序。
6. 同构的JavaScript
   单页面JS应用程序的最大缺陷在于对搜索引擎的索引有很大限制。React对此有了解决方案。
   React可以在服务器上预渲染应用再发送到客户端。它可以从预渲染的静态内容中恢复一样的记录到动态应用程序中。
   因为搜索引擎的爬虫程序依赖的是服务端相应而不是JavaScript的执行，预渲染你的应用有助于搜索引擎优化。
7. React与其他框架/库相比兼容性好
   比如使用RequireJS来加载和打包，而Browserify和Webpack适用于构建大型应用。它们使得那些艰难的任务不再让人望而生畏。
8. 相比于其他的框架【vue】更灵活
   没有那么多的条条框框，提供了一系列基础api自己随意组合。如果要我把他比作积木的话那么react提供的就是小型的积木，vue提供的是大型的积木。这就势必造成了react会比vue更加的灵活。



### React hooks解决了什么问题? 函数组件与类组件的区别

React Hooks 解决了函数组件在状态管理、副作用处理等方面的限制问题，使得函数组件可以具备类组件的状态管理能力，并且更加灵活和可复用。

具体来说，React Hooks 提供了 `useState`、`useEffect`、`useContext` 等钩子函数，使得函数组件可以：

1. **状态管理**：使用 `useState` 可以在函数组件中定义和更新状态，替代了类组件中的 `this.state` 和 `this.setState`。
2. **副作用处理**：使用 `useEffect` 可以在函数组件中进行副作用操作，如数据获取、订阅事件等，替代了类组件中的生命周期方法（如 `componentDidMount`、`componentDidUpdate`、`componentWillUnmount`）。
3. **逻辑复用**：自定义 Hooks 可以让逻辑在组件之间共享，使得代码更加可维护和复用，而不需要使用高阶组件或 render props。

函数组件和类组件的区别主要在于以下几点：

- **语法和写法**：函数组件是简单的 JavaScript 函数，直接返回 JSX。而类组件是 ES6 的类，需要继承自 `React.Component`，并且有 render 方法来返回 JSX。
- **状态管理**：函数组件以前只能通过 props 来管理状态，现在可以使用 Hooks 来管理局部状态。而类组件可以通过 `this.state` 和 `this.setState` 来管理组件状态。
- **生命周期**：函数组件没有生命周期方法，Hooks 提供了类似生命周期的功能。类组件具有多个生命周期方法（如 `componentDidMount`、`componentDidUpdate`、`componentWillUnmount` 等）来处理组件的不同阶段。

### SetState是同步还是异步的，setState做了什么

在React中，`setState()`函数通常被认为是异步的，这意味着调用setState()时不会立刻改变react组件中state的值，setState通过触发一次组件的更新来引发重汇，多次setState函数调用产生的效果会合并

调用 setState时，React会做的第一件事情是将传递给 setState的对象合并到组件的当前状态。这将启动一个称为和解（reconciliation）的过程。和解（reconciliation）的最终目标是以最有效的方式，根据这个新的状态来更新UI

### React组件传值有哪些方式

父传子：props 子传父：通过在父组件引入的子组件中传递一个函数并传参数，子组件去触发这个函数更改参数完成数据更新

跨多层组件传值：通过context api完成

### react无状态组件和class类组件的区别

直观区别，函数组件代码量较少，相比类组件更加简洁

函数组件看似只是一个返回react元素的函数，其实体现的是无状态组件的思想，函数组件中没有this， 没有state，也没有生命周期，这就决定了函数组件都是展示性组件，接收props，渲染dom，而不关注其他逻辑

因为函数组件不需要考虑组件状态和组件生命周期方法中的各种比较校验，所以有很大的性能提升空间

### react如何做到和vue中keep-alive的缓存效果

React Keep Alive 提供了 ，你必须把 放在 Provider 里面，并且每个 组件都必须拥有一个唯一的 key

### React有哪几种方式改变state

this.forceUpdate this.setState :key值传递不同也可以 replaceState也可以改变

### React有哪几种创建组件方法

React 有三种构建组件的方式

- React.createClass
- ES6 class
- 无状态函数

### react中props和state有什么区别

props 是传递给组件的（类似于函数的形参），而 state 是在组件内被组件自己管理的（类似于在一个函数内声明的变量）

props 是不可修改的

### React 中 keys 的作用是什么？

Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。

在 React 中渲染集合时，向每个重复的元素添加关键字对于帮助React跟踪元素与数据之间的关联非常重要

### React 中 refs 的作用是什么？

在 React 中，`refs` 是用来获取组件或 DOM 元素的引用的方式。它提供了一种在函数组件或类组件中访问 DOM 节点或 React 元素的方法。

具体来说，`refs` 的作用包括：

1. **访问 DOM 元素**：通过 `refs` 可以获取到组件渲染后生成的 DOM 元素的引用。这对于需要直接操作 DOM 的情况非常有用，如聚焦元素、测量元素大小、或者执行其他 DOM 操作。
2. **访问 React 组件实例**：对于类组件，可以通过 `refs` 访问到组件的实例，从而调用组件内部的方法或访问其状态。
3. **在函数组件中进行操作**：在函数式组件中，可以使用 `useRef` 钩子来创建 `refs`，以便在函数组件中操作 DOM 或者获取组件实例的引用。
4. **传递引用给子组件**：可以将 `refs` 作为 props 传递给子组件，从而让子组件能够通过 `props` 获取父组件的 DOM 元素或者组件实例。

还有个高级用法，就是函数式组件接收第二个参数，也就是ref

### 受控组件和非受控组件有什么区别？

受控组件是指表单元素的值（如 `<input>`、`<textarea>`、`<select>` 等）由 React 组件的状态（state）控制的组件

非受控组件是指表单元素的值不受 React 组件状态控制，而是由 DOM 自身管理的组件

### 为什么虚拟 dom 会提高性能?

**批量更新与高效 diff 算法： **React 使用高效的 diff 算法（例如基于比较节点类型、属性和顺序等）来比较新旧虚拟 DOM 树的差异，找出需要实际更新的最小变更集

**最小化实际 DOM 操作**： 

- 虚拟 DOM 的存在使得 React 可以通过一系列的比较和批量更新，最终将变更一次性应用到实际 DOM 上。
- 实际的 DOM 操作是相对昂贵的，直接对其进行频繁操作可能会导致性能下降。通过虚拟 DOM，React 可以尽可能减少对实际 DOM 的直接操作，从而提高性能。

### React为什么要搞一个Hooks？

React 引入 Hooks 主要是为了解决类组件在复杂逻辑复用、代码结构和性能优化上的一些限制和问题

1. **函数组件的增强**：
   - 在 React 之前，函数组件受到了一些限制，例如无法使用状态（state）和生命周期方法，这使得复杂的逻辑和状态管理更适合使用类组件。Hooks 的引入让函数组件可以像类组件一样拥有状态管理和生命周期钩子，从而扩展了函数组件的功能。
2. **逻辑复用和组件间共享状态的简化**：
   - Hooks 提供了一种更方便和灵活的方式来封装和复用逻辑。通过自定义 Hooks，可以将组件之间共享的逻辑抽取到单独的函数中，然后在多个组件中重复使用。这种方式比传统的高阶组件或者 render props 更直观和简洁。
3. **代码结构的优化和可读性的提高**：
   - 使用 Hooks 可以减少组件间的嵌套层级和代码冗余，使得组件更加扁平化和易于理解。相比于类组件中的复杂生命周期方法和状态管理，Hooks 提供了更直观的方式来管理组件的状态和副作用。
4. **性能优化和更新策略的改进**：
   - Hooks 的设计使得 React 内部可以更精细地控制组件的更新策略，避免不必要的重新渲染和副作用。例如，useEffect 钩子可以根据依赖项进行优化，只在特定条件下执行副作用操作，而不是每次组件更新都执行。
5. **更容易实现复杂的状态逻辑**：
   - Hooks 的灵活性使得开发者可以更容易地实现复杂的状态逻辑，例如使用 useReducer 来管理复杂的状态转换逻辑，或者使用 useContext 在组件树中共享状态。

总体而言，React 引入 Hooks 是为了提高开发效率、改善代码结构和性能优化，并且使得函数式组件在功能和使用上更接近于类组件，同时减少了一些传统 React 组件开发中的模式和复杂性。Hooks 的引入让 React 应用能够更加灵活、可维护和高效地进行开发。

### 函数式组件有没有生命周期？

函数式组件是无状态组件，既然是无状态的，那就没有生命周期

### 怎么防止HTML被转义？

```
dangerouslySetInnerHTML
```

### 说说你是如何提高组件的渲染效率的

   **使用 React.memo 进行记忆化**

- `React.memo` 是一个高阶组件，用于包裹函数组件，在组件 props 不变的情况下，避免不必要的重新渲染。它通过浅比较 props 来确定是否重新渲染组件

  **避免在 render 方法中创建对象**：

- 在 render 方法中创建新的对象会导致每次渲染都会生成新的对象引用，即使值没有发生变化，也会触发子组件的不必要重新渲染。可以通过将对象定义在组件外部，或者使用 useMemo 来缓存对象。

 **使用 useCallback 缓存回调函数**：

- `useCallback` 用于缓存回调函数，避免在每次渲染时创建新的函数引用，尤其是当传递给子组件的 prop 是一个函数时。

**优化子组件的渲染**：

- 如果子组件的渲染不受父组件 props 的影响，可以使用 `React.memo` 包裹子组件，避免不必要的重新渲染。
- 同时，可以将子组件的 props 分解成更小的部分，只传递需要更新的 props，而不是传递整个对象。

**使用 key 来优化列表渲染**：

- 在渲染列表时，确保每个列表项都有稳定的唯一 `key`。这可以帮助 React 识别列表项的变化，从而更高效地更新 DOM。
- `key` 的选择应该是稳定且唯一的，最好不要使用索引作为 `key`。